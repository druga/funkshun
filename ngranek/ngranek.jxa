(ns ngranek-data
    (use
     ; old style
     (joxa-records :only (defrecord+/2))))

(defmacro purple ()
  `[128 0 128])

(defmacro crimson ()
  `[220 20 60])

(defrecord+ :data
  {screen {800 600}}
  {fov 75}
  {pov ((50 . 80) . (50 . 50))}
  {objs [((crimson) . [((10 . 20) . (20 . -10)) ((0 . -20) . (-20 . 0))
				 ((30 . 0) . (40 . 0)) ((40 . -10) . (30 . -10))])
	      ((purple) . [((-20 . 0) . (10 . 20)) ((20 . -10) . (0 . -20))
				((30 . -10) . (30 . 0)) ((40 . 0) . (40 . -10))])]})

(ns ngranek
    (require gl glu wx
	     (wxFrame :as wxframe)
	     (wxWindow :as wxwindow
		       ;:rename ((createStatusBar/2 createbar))
		       )
	     (wxMenu :as wxmenu)
	     (wxMenuBar :as wxbar)
	     (wxGLCanvas :as wxglcanvas)
	     ngranek-data erlang)
    (use io erlang joxa-core math lists)
    ;(include-lib 'wx/include/wx.hrl')
)

;; helpers
(defn unfold (beg pred fun cons inc acc)
  (if (pred beg)
     (unfold (inc beg) pred fun cons inc (cons (fun beg) acc))
    acc ;(reverse acc)
    ))

(defn unfold (beg pred fun cons inc)
  (unfold beg pred fun cons inc []))

;(defmacro compose (f g)
;  `(fn (x) (~f (~g x))))

;(defmacro multicompose (f . fs)
;  `(foldl (fn (x) x) f fs))

(defn andalso (&rest args)
  (case args
    ([x y]
     (if x y :false))
    ((_ . _)
     (all (fn (x) x) args))))

;(defn orelse (&rest args)
;  (case args
;    ([x y]
;     (if x :true y))
;    ((_ . _)
;     (any (fn (x) x) args))))

;(defmacro non-empty? (f)
;  `(if (== f [])
;       :false
;     :true))

(defn fdiv (&rest args)
  (case args
    ([x y]
     (if (:'/=' y 0)
	 ; joxa syntax issue workaround
	 (:'/' x y)
       []))
    (_
     (foldl (fn (x prod) (fdiv prod x)) (hd args) (tl args)))))
;;

;; vector algebra
(defmacro dot-product (v1 v2)
	`(erlang/+ (* (hd ~v1) (hd ~v2)) (* (tl ~v1) (tl ~v2))))

(defmacro sqr-len (v)
	`(dot-product ~v ~v))

(defn vec-len (v)
	(sqrt (sqr-len v)))

; normalize to skip some extra calcs
(defn vec-norm (v)
  (let* (mul (fdiv 1 (vec-len v)))
     ((* (hd v) mul) . (* (tl v) mul))))

(defn vec-perp (v dir)
  (if (== dir :left)
       ((erlang/- (tl v)) . (hd v))
     ((tl v) . (erlang/- (hd v)))))

(defmacro vec-op (op v2 v1)
	`((~op (hd ~v2) (hd ~v1)) . (~op (tl ~v2) (tl ~v1))))

(defn vec-rot (v an)
    ((erlang/- (* (hd v) (cos an)) (* (tl v) (sin an))) .
     (erlang/+ (* (hd v) (sin an)) (* (tl v) (cos an)))))

;(defmacro vec-rev (v)
;  `((erlang/- (hd ~v)) . (erlang/- (tl ~v))))

(defmacro vec-angle (v1 v2)
  `(acos (dot-product ~v1 ~v2)))

;; ray casting
(defmacro line-vn (d1 d2)
  `(vec-norm (vec-op erlang/- ~d2 ~d1)))

(defmacro get-yf (vface dot)
  ; canonical line equation
  `(fn (x) (erlang/+ (fdiv (* (tl ~vface) (erlang/- x (hd ~dot))) (hd ~vface)) (tl ~dot))))

;(defmacro get-xf (vface dot)
;  `(fn (y) (erlang/+ (fdiv (* (hd ~vface) (erlang/- y (tl ~dot))) (tl ~vface)) (hd ~dot))))

;(defmacro incrf (dir-inc)
;  `(fn (dot) (let* (x (dir-inc (hd dot)))
;			      (x . (yf x)))))

(defmacro dir-incr (dir add)
  `(if (> ~dir 0)
  (fn (x) (erlang/+ x ~add))
  (fn (x) (erlang/- x ~add))))

(defn trunc-fov (pov pn ppn hfov hwidth)
  (let* (ppv (vec-op * ppn (hwidth . hwidth))
	     side-dot (vec-op erlang/+ (tl pov) ppv)
	     newhfov (vec-angle (line-vn (hd pov) side-dot) pn))
    (if (> hfov newhfov)
	(do (format "fov truncated to ~w by width~n" [(* newhfov 114.6)])
	    newhfov)
	  hfov)))

;; shapes handling
(defmacro face-vrecalc (beg end recalc? p)
  `(if ~recalc?
       ; we need a new direction
      (erlang/- ~end ~beg)
    ~p))

(defmacro dir-bound (dir end)
  `(if (gte ~dir 0)
       (fn (x) (lte x ~end))
     (fn (x) (gte x ~end))))

(defn get-intersect (v1 v2 d1 d2)
  ; x extracted from equation system
  (let* (p1p3 (* (hd v1) (hd v2))
	 p2p3 (* (tl v1) (hd v2))
	 p1p4 (* (hd v1) (tl v2)))
    (fdiv (erlang/+ (erlang/- (* p1p3 (erlang/- (tl d2) (tl d1))) (* p1p4 (hd d2)))
		     (* p2p3 (hd d1)))
	       (erlang/- p2p3 p1p4))))

(defmacro find-intersect (beg end vface face-len pos side)
  `(let* (x (get-intersect vface ~side beg pos)
                   dot (x . ((get-yf vface beg) x)))
     ; dot is between A & B
     (if (andalso (< (vec-len (vec-op erlang/- beg dot)) face-len)
                   (< (vec-len (vec-op erlang/- end dot)) face-len))
         dot
       [])))

(defmacro choose-intersect (beg end vface face-len pos side1 side2)
  `(let* (intersect (find-intersect beg end vface face-len pos ~side1))
     (if (== intersect [])
	 (find-intersect beg end vface face-len pos ~side2)
       intersect)))

(defn gen-face-dots (beg end vface vface-delta recalc?)
  (let* (cons (fn (x acc) (x . acc)))
    ; moving all along the face vector
    ;(beg .
    (case vface
      ((p1 . 0)
       (let* (p (face-vrecalc (hd beg) (hd end) recalc? p1)
	      dir-inc (dir-incr p 1)
	      inc (fn (dot) ((dir-inc (hd dot)) . (tl beg)))
	      within-bounds? (dir-bound p (hd end)))
	 (unfold (inc beg)
	       (fn (dot) (within-bounds? (hd dot)))
	       (fn (dot) dot)
	       cons
	       inc)))
      ((0 . p2)
       (let* (p (face-vrecalc (tl beg) (tl end) recalc? p2)
	      dir-inc (dir-incr p 1)
	      inc (fn (dot) ((hd beg) . (dir-inc (tl dot))))
	      within-bounds? (dir-bound p (tl end)))
	 (unfold (inc beg)
	       (fn (dot) (within-bounds? (tl dot)))
	       (fn (dot) dot)
	       cons
	       inc)))
      ((p1 . p2)
       (let* (;yf (get-yf vface beg)
		 px (face-vrecalc (hd beg) (hd end) recalc? p1)
		 py (face-vrecalc (tl beg) (tl end) recalc? p2)
		 dir-incx (dir-incr px (hd vface-delta))
		 dir-incy (dir-incr py (tl vface-delta))
		 ;inc (incrf dir-inc)
		 inc (fn (dot) ((dir-incx (hd dot)) . (dir-incy (tl dot))))
		 within-bounds? (dir-bound px (hd end)))
	  (unfold (inc beg)
		  (fn (dot) (within-bounds? (hd dot)))
		  (fn (dot) dot)
		  cons
		  inc))))))

(defn face-dots (beg end vface vface-delta face-len pos pn hfov sides)
  (if (lte (vec-angle (line-vn pos beg) pn) hfov)

      (if (lte (vec-angle (line-vn pos end) pn) hfov)
	  ; all dots inclusion
	  (gen-face-dots beg end vface vface-delta :false)
	; A + face part
	(gen-face-dots beg (choose-intersect beg end vface face-len pos (hd sides) (tl sides)) vface vface-delta :true))

    (if (lte (vec-angle (line-vn pos end) pn) hfov)
	; B + face part
	(gen-face-dots end (choose-intersect beg end vface face-len pos (hd sides) (tl sides)) vface vface-delta :true)
      (let* (intersect (find-intersect beg end vface face-len pos (hd sides)))
	 (if (== intersect [])
	     ; face isn't in fov
	     []
	   ; face is bigger than fov
	     (gen-face-dots intersect (find-intersect beg end vface face-len pos (tl sides)) vface vface-delta :true))))
    ))

(defmacro make-face-dots (pos pn hfov sides)
  `(fn (face) (face-dots (element 1 face) (element 2 face) (element 3 face) (element 4 face) (element 5 face) ~pos pn hfov sides)))
;;

(defn plane-dots (objs beg pn hfov sides)
  (let* (dots-fun (make-face-dots beg pn hfov sides)
		  ; get list of flatten lists of dots
	 dots (foldl (fn (x acc) (++ (dots-fun x) acc))
						 []
						 objs))
	dots))

(defn setup-menus (frame)
  (let (bar (wxbar/new)
	    menu (wxmenu/new)
	    :true (wxbar/append bar menu "&File"))
    ; C-q is good too
    (wxmenu/append menu 10 "Exit")
    (let (:ok (wxframe/connect frame :command_menu_selected)
	      :ok (wxframe/setMenuBar frame bar))
      [])
    ;
    ))

(defn draw-canvas (frame canvas)
  ; GL_COLOR_BUFFER_BIT bor GL_DEPTH_BUFFER_BIT
  (gl/clear 16640)

  (gl/begin 0) ; GL_POINTS
  (gl/vertex2i 50 40)
  (gl/end)

  (wxglcanvas/swapBuffers canvas)
  (wxwindow/getSize frame))

(defn gui-loop (frame canvas)
  (receive
   (after 200

	  (draw-canvas frame canvas)
	  (let (0 (gl/getError))
	       (gui-loop frame canvas)))
   ({:wx _ _ _ {wxClose :close_window}}
    :ok)
   ({:wx 10 _ _ _}
    (wxwindow/close frame)
    :ok)
   ({'_wxe_error_' _ _}
    :fail)
   (event
    ;(format "Received ~p~n" [event])
    (gui-loop frame canvas))))

(defn+ start ()
  (let (wx (wx/new)
	   data (ngranek-data/make-fields [])
	   screen (ngranek-data/screen data)
	   frame (wxframe/new wx 1 "Ray casting shit" [{:size screen}
							    ; wxDEFAULT_FRAME_STYLE band bnot
							    ; wxRESIZE_BORDER band bnot 
							    ; wxMAXIMIZE_BOX
							    ;{:style 541072384}
							    ])
	   ; working close
	   :ok (wxframe/connect frame :close_window))
    ; (wxframe/createStatusBar frame)
    (setup-menus frame)
    (let* (canvas (wxglcanvas/new frame)
		  pov (ngranek-data/pov data) pv (vec-op erlang/- (tl pov) (hd pov)) pn (vec-norm pv)
		  hfov (trunc-fov pov pn (vec-norm (vec-perp pv :left))
				  (fdiv (fdiv (* (ngranek-data/fov data) (pi)) 180) 2)
				  (:'/' (element 1 screen) 2))
		  ; precalc vectors & lens, assign colors
		  objs (flatmap (fn (item) (map
					 (fn (face) (let* (vface (vec-op erlang/- (tl face) (hd face))
								 len (vec-len vface)
								 norm (fn (v)
									(let* (mul (fdiv 1 len))
									  ((abs (* (hd v) mul)) . (abs (* (tl v) mul))))))
							  {(hd face) (tl face) vface (norm vface) len (hd item)}))
						 (tl item)))
			    (ngranek-data/objs data))
		  side1-pv (vec-rot pv hfov) side2-pv (vec-rot pv (erlang/- hfov)))
      (wxwindow/connect canvas :motion)
      (wxwindow/show frame)
      (wxglcanvas/setCurrent canvas)
      (gl/clearColor 0 0 0 0)
      (gl/clearDepth 1)

      (gl/color3ub 220 20 60)
      (gl/pointSize 10)
      (gl/matrixMode 5889) ; GL_PROJECTION
      (gl/loadIdentity)
      (glu/ortho2D 0 (element 1 screen) 0 (element 2 screen))

      (format "~p~n" [
		      (plane-dots objs (hd pov) pn hfov (side1-pv . side2-pv))
      ])

      (gui-loop frame canvas)
      (wx/destroy))))
